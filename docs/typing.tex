\documentclass{article}
% \documentclass{notes}
% \usepackage{graphicx} % Required for inserting images
\usepackage{amsmath} % Required for some math elements
\usepackage{amsfonts} 
\usepackage{pl-syntax/pl-syntax} 
\usepackage{mathpartir} % Required for the math environment
\usepackage{stmaryrd}
\usepackage{appendix} % Required for the appendices
\usepackage{adjustbox} % Used to center the code snippets
\usepackage{indentfirst} % Indent the first paragraph of a section
\usepackage{tikz} % Required for drawing the syntax tree
\usepackage[draft]{fixme}  % change [draft] to [final] to hide fixme notes
\usepackage[backend=biber,style=numeric,sorting=none]{biblatex} % bibliography, install biber otherwise it will not work
\addbibresource{typing.bib} 
\usepackage[colorlinks=true, linkcolor=cyan, citecolor=cyan, urlcolor=blue]{hyperref} % hyperlink


\DefineBibliographyStrings{english}{
    % add bibliography page to table of contents
    bibliography = {References},
}

\setlength{\parskip}{1ex} % space between paragraphs


\title{Pirouette - Type Inference}
\author{\textbf{Alex Kim} \and \textbf{Vincent Chan}}
\date{November 2024}


\begin{document}

\maketitle

\listoffixmes{} % list of fixme notes that need to be fixed in the doc

\section{Background}

\subsection{Introduction of Type Inference}
    Type inference is the process of automatically deducing the types of expressions in a program.
    For example, in the following code snippet, the type of the whole expression can be inferred to be \texttt{int}:

    \begin{center}
        \setlength{\fboxsep}{5pt}
        \adjustbox{valign=t,margin=1ex,center}{
            \begin{minipage}{1\textwidth}
                \begin{verbatim}
                        let x := 5 + 2 in
                            x + 3
                    \end{verbatim}
            \end{minipage}
        }
    \end{center}

    To get the type of \texttt{x}, we can infer the type of the expression \texttt{5 + 2}, and then assign that type to \texttt{x}.
    To get the type of \texttt{5 + 2}, we can infer the type of \texttt{5} to be \texttt{int} and the type of \texttt{2} to be \texttt{int}
    because they are both constants, and in our type scheme, we have the rule that the type of \texttt{+} is \texttt{int -> int -> int}, so the type of \texttt{5 + 2} is \texttt{int}.
    Therefore, the type of \texttt{x} is \texttt{int}, and the type of the whole expression of let binding is \texttt{int}. After the binding of \texttt{x:int}, we now examine the type of expression \texttt{x + 3},
    we need to bring the type binding of \texttt{x} into the scope of the expression. The data structure that we use to store the type bindings \texttt{variable\_name:type} is called the \textit{context}.
    Follow the same process as before, when we infer the function body \texttt{x + 3}, we know that the type of {+} is \texttt{int -> int -> int}, and the type of \texttt{3} is \texttt{int},
    and since \texttt{x} is a variable, we look up the type of \texttt{x} in the context, and we find that the type of \texttt{x} is \texttt{int}, so the type of the whole expression is \texttt{int}.

    But things can get more complicated when we have more complex expressions, such as function definition, function applications, and polymorphic types.
    Because we may not know the type of a program yet, and we can certainly collect constraints on the types of expressions,
    our approach to type inference is to collect constraints on the types of expressions, and then solve these constraints to get the type of the program.
    The way to solve these constraints is to use the \textit{unification algorithm}.

    Consider the following code snippet from the lecture note of Northeastern University\cite{NEU1}:

    \begin{center}
        \setlength{\fboxsep}{5pt}
        \adjustbox{valign=t,margin=1ex,center}{
            \begin{minipage}{0.9\textwidth}
                \begin{verbatim}
                        def f(x) := 
                            x + 6

                        f 38
                    \end{verbatim}
            \end{minipage}
        }
    \end{center}

    At the beginning, we need to infer the type of the parameter \texttt{x} in the function \texttt{f}.
    Since we don't know the type of \texttt{x} yet, we can assign a type variable \texttt{T1} to it, and add it into the context.
    Then we go to function body \texttt{x + 6}, and we know that the type of \texttt{6} is \texttt{int}, since the type of \texttt{+} is \texttt{int -> int -> int},
    and the type of \texttt{x} is \texttt{T1}, we unify our conclusion with the type \texttt{T1} to produce a constraint/substitution \texttt{T1 = int}, the return type of the function body
    is the type of the last expression, which is \texttt{int}. Therefore, the type of the function \texttt{f} is \texttt{int -> int}.

    When we infer the type of the function application \texttt{f 38}, we infer the type of the function \texttt{f} to be \texttt{int -> int}, and
    the type of the argument \texttt{38} to be \texttt{int}, and we unify the type of the argument with the type of the parameter in the function type,
    and the return type of the function application is the return type of the function, which is \texttt{int}.

    There are some other resources that may help in understanding the unification algorithm and the type inference process.
    The note from Cornell\cite{Cornell} provides an explanation of the type inference process,
    the terms used in Cornell note are not the same as the terms used in this note, but it gives the general idea of how unification and substitution work.
    The cornerstone of our implementation of the unification algorithm is another note from Northeastern University\cite{NEU2}.
    We follow the formal rules for the unification, generation, and solution of the substitution, which are given in Section 3 of the note.
    If the above resources are confusing, this blog post\cite{TypInferBlog} provides a more intuitive explanation of type inference.
    The good thing is that the blog post uses the Abstract Syntax Tree $(AST)$\cite{ASTBlog} to represent the program,
    which is the same as our implementation, it may help to understand the type inference process by visualizing the $AST$.
    Also we would like to refactor our code to annotate the nodes in the $AST$ with types, it is more intuitive to understand
    the process of type annotation by bottom-up traversal of the $AST$. This blog post also talks a bit about inferring polymorphic types,
    which is one of the goals of this type inference library.


\subsection{The syntax of the language}
    The syntax of Pirouette is divided into three parts: the local language, the choreographic language, and the network language.
    Here we just pick the binary operation expression from the local language as an example to show how to represent the language in syntax tree.

    Suppose we have a string \texttt{5 + 2} in the source code.
    The lexer will tokenize the string into a list of tokens, and the parser will parse the list of tokens into a syntax tree.
    Lexer and parser are implemented in the \texttt{lib/parsing/lexer.mll} and \texttt{lib/parsing/parser.mly} respectively.
    The definition of the syntax tree is in the \texttt{lib/ast\_core/local.ml \& choreo.ml}. In \texttt{local.ml},
    we can find the definition of the binary operation expression:

    \begin{center}
        \setlength{\fboxsep}{5pt}
        \adjustbox{valign=t,margin=1em,center}{
            \begin{minipage}{1.2\textwidth}
                \begin{verbatim}
                    type 'a expr =
                        | ...
                        | BinOp of 'a expr * 'a bin_op * 'a expr * 'a
                        | ...
                    \end{verbatim}
            \end{minipage}
        }
    \end{center}

    The \texttt{BinOp} constructor takes three arguments, the left-hand side expression, the binary operator, and the right-hand side expression.
    the syntax tree of the expression \texttt{5 + 2} will be represented as:

    \begin{center}
        \begin{tikzpicture}
            \node {+}
            child {node {5}}
            child {node {2}};
        \end{tikzpicture}
    \end{center}


\subsection{Understanding the Type System}
    The type system is a set of rules that define the types of expressions in the program.
    The rules are written in the form of inference rules, which are a set of premises and a conclusion.
    Consider the following example:

    \[
        \inferrule [ Loc - binop mat ]
        { \Gamma \vdash e_1 : int \quad \Gamma \vdash e_2 : int \quad \odot \in \{+,-,\times, /\}}
        { \Gamma \vdash e_1 \odot e_2 : int} \and
    \]

    The above rule is the rule for the binary operation of mathematical operators. Generally, the top line of the rule is the premise, and the bottom line is the conclusion.
    The Gamma $\Gamma$ is the local context that stores the type bindings of local variables in the program (we use Delta $\Delta$ for choreographic context).
    The turnstile $\vdash$ means that the type of the expression on the right-hand side of $\vdash$ can be inferred from the context on the left-hand side of $\vdash$.
    So, in the premise of the binop rule, if we infer the type of the left-hand side expression $e_1$ and the right-hand side expression $e_2$ to be \texttt{int} from the context $\Gamma$,
    and the operator $\odot$ is one of these four mathematical operators, then in the conclusion of the rule, we can infer the type of the whole expression
    $e_1 \odot e_2$ to be \texttt{int} from the context $\Gamma$.

    Consider another example:

    \[
        \inferrule [ Loc - def ]
        { \Gamma \vdash e_1 : t \quad \Gamma, x : t \vdash e_2 : t_2 }
        { \Gamma \vdash \textsf{let}\ x := e_1 \ \textsf{in}\ e_2 : t_2  } \and
    \]

    The above rule is the rule for the let binding expression. The let binding expression is used to bind a value to a variable name,
    and then use the variable in the expression that follows the \texttt{in} keyword.
    In terms of the scoping, the variable name $x$ is only available in the expression $e_2$.
    In the premise, we first infer the type of the expression $e_1$ to be $t$ from the context $\Gamma$ first.
    Then when we infer the type of the expression $e_2$, the $\Gamma, x:t$ means that we extend the context $\Gamma$ by adding the type binding $x:t$ to it,
    so that we can access the type of $x$ in the expression $e_2$ by looking up the type of $x$ in the updated context $\Gamma, x:t$, and infer the type of $e_2$ to be $t_2$.
    So in the conclusion of the rule, we can infer the type of the whole let binding expression to be $t_2$ from the context $\Gamma$.

    \newpage % end of section


\section{Details}
\subsection{Type Definition}
    \begin{itemize}
        \item \textbf{typvar} \\
              A type variable is a placeholder for a type that we don't know yet. We use type variables to represent unknown types in our type inference process.
        \item \textbf{local\_subst \& choreo\_subst} \\
              A substitution is a mapping from type variables to types. We use substitutions to represent the constraints on the types of expressions. The example of a local substitution is \texttt{[(T1, int), (T2, int -> int)]}.
        \item \textbf{local\_ctx \& choreo\_ctx \& global\_ctx} \\
              A context is a mapping from variable names to types. We use contexts to store the type bindings of variables in the program. The example of a local context is \texttt{[(foo, int), (bar, bool)]}.
              The global context is the context that stores the type bindings of all the variables including different locations in the program.
              The example of a global context is \texttt{[(Alice, foo, int), (Bob, foo, bool), (Alice, bar, string)]}.
              The choreographic context is the context that stores the choreographic type bindings in the choreographic language.
    \end{itemize}

\subsection{Auxiliary Functions}
    \fxnote{Add the explaination of the auxiliary functions}
    \begin{itemize}
        \item \textbf{extract\_local\_ctx}
        \item \textbf{get\_choreo\_ctx}
        \item \textbf{gen\_ftv}
        \item \textbf{occurs\_in}
        \item \textbf{get\_choreo\_subst}
        \item \textbf{unify\_local \& unify\_choreo}
        \item \textbf{apply\_subst\_typ\_local \& apply\_subst\_typ\_choreo}
        \item \textbf{apply\_subst\_ctx\_local \& apply\_subst\_ctx\_choreo}
    \end{itemize}

\subsection{Type Inference for Local Language}
    The type system for the local language can be found in the \hyperref[appendix:local_typ]{Appendix B}.
    \fxnote{Add the explaination of some of the cases for the local language}

\subsection{Type inference for Choreographic Language}
    The type system for the choreographic language can be found in the \hyperref[appendix:choreo_typ]{Appendix C}.
    \fxnote{Add the explaination of some of the cases for the choreographic language}

    \newpage % end of section

\section{Appendices}
    \begin{appendices}
        \renewcommand{\thesubsection}{Appendix \Alph{subsection}}

        \subsection{Type System for Local Language}\label{appendix:local_typ}
            \begin{mathpar}
                \inferrule [ Loc - unit ]
                { \; }
                { \Gamma \vdash \textsf{() : unit} } \and
                \inferrule [ Loc - var ]
                { x : t \in \Gamma }
                { \Gamma \vdash x : t  } \and
                \inferrule [ Loc - binop mat ]
                { \Gamma \vdash e_1 : int \quad \Gamma \vdash e_2 : int \quad \odot \in \{+,-,\times, /\}}
                { \Gamma \vdash e_1 \odot e_2 : int} \and
                \inferrule [ Loc - binop comp ]
                { \Gamma \vdash e_1 : int \quad \Gamma \vdash e_2 : int \quad \odot \in \{=, !=, <, >, <=, >=\}}
                { \Gamma \vdash e_1 \odot e_2 : bool} \and
                \inferrule [ Loc - binop bool ]
                { \Gamma \vdash e_1 : bool \quad \Gamma \vdash e_2 : bool \quad \odot \in \{\& \&, \parallel\}}
                { \Gamma \vdash e_1 \odot e_2 : bool} \and
                \inferrule [ Loc - def ]
                { \Gamma \vdash e_1 : t \quad \Gamma, x : t \vdash e_2 : t_2 }
                { \Gamma \vdash \textsf{let}\ x := e_1 \ \textsf{in}\ e_2 : t_2  } \and
                \inferrule [ Loc - pair ]
                { \Gamma \vdash e_1 : t_1 \quad \Gamma \vdash e_2 : t_2}
                { \Gamma \vdash (e_1, e_2) : t_1 \times t_2 } \\
                \inferrule [ Loc - fst ]
                { \Gamma \vdash e : t_1 \times t_2 }
                { \Gamma \vdash \textsf{fst} \  e : t_1 } \and
                \inferrule [ Loc - snd ]
                { \Gamma \vdash e : t_1 \times t_2 }
                { \Gamma \vdash \textsf{snd} \ e : t_2 } \\
                \inferrule [ Loc - left ]
                { \Gamma \vdash e_1 : t_1 }
                { \Gamma \vdash \textsf{left} \ e_1 : t_1 + t_2 } \and
                \inferrule [ Loc - right ]
                { \Gamma \vdash e_2 : t_2 }
                { \Gamma \vdash \textsf{right} \ e_2 : t_1 + t_2 } \and
                \inferrule [ Loc - match ]
                { \Gamma \vdash e : t_1+t_2 \quad \Gamma , \ x : t_1 \vdash e_1 : t_3 \quad \Gamma , \ y : t_2 \vdash e_2 : t_3  }
                { \Gamma \vdash (\textsf{match e with left} \ x \Rightarrow e_1 ; \textsf{right} \ y \Rightarrow e_2) :t_3  }

            \end{mathpar}
            \newpage % end of section


        \subsection{Type System for Choreography}\label{appendix:choreo_typ}
            \begin{mathpar}
                \inferrule [ unit ]
                { \; }
                { \Gamma ; \Delta \vdash \textsf{() : unit} } \and
                \inferrule [ var ]
                { X : \tau \in \Delta }
                { \Gamma ;\Delta \vdash X : \tau } \and
                \inferrule [ done ]
                { \Gamma_{|\ell} \vdash e : t }
                { \Gamma ; \Delta \vdash \ell.e : \ell.t } \and
                \inferrule [ send ]
                { \Gamma ; \Delta \vdash C : \ell.t}
                { \Gamma;\Delta \vdash C \leadsto \ell_2 : \ell_2.t} \and
                \inferrule [ sync ]
                { \Gamma;\Delta \vdash C : \tau}
                { \Gamma;\Delta \vdash \ell_1[d] \leadsto \ell_2 ; C : \tau} \and
                \inferrule [ if ]
                { \Gamma;\Delta \vdash C_1 : \ell.bool \quad \Gamma;\Delta\vdash C_2 : \tau_2 \quad \Gamma;\Delta \vdash C_3 : \tau_2 }
                { \Gamma;\Delta \vdash \textsf{if } C_1 \textsf{ then } C_2 \textsf{ else } C_3: \tau_2  } \and
                \inferrule [ def ]
                { \Gamma;\Delta \vdash C_1 : \ell.t \quad \Gamma;\Delta, X : \ell.t \vdash C_2 : \tau_2 }
                { \Gamma;\Delta \vdash \textsf{let } X = C_1 \textsf{ in } C_2 : \tau_2 } \and
                \inferrule [ fun ]
                { \Gamma ;\Delta , X : \tau_1, F : \tau_1 \to \tau_2\vdash C : \tau_2 }
                { \Gamma ;\Delta \vdash \textsf{fun}\ F \ X \Rightarrow C : \tau_1 \to \tau_2  } \and
                \inferrule [ app ]
                { \Gamma;\Delta \vdash C_1 : \tau_1 \to \tau_2 \quad \Gamma;\Delta \vdash C_2 : \tau_1 }
                { \Gamma;\Delta \vdash C_1 C_2 : \tau_2  } \and
                \inferrule [ pair ]
                { \Gamma ; \Delta \vdash C_1 : \tau_1 \quad \Gamma ; \Delta \vdash C_2 : \tau_2 }
                { \Gamma ; \Delta \vdash (C_1, C_2) : \tau_1 \times \tau_2  } \and
                \inferrule [ fst ]
                { \Gamma ; \Delta \vdash C : \tau_1 \times \tau_2 }
                { \Gamma ; \Delta \vdash \textsf{fst}\ C : \tau_1 } \and
                \inferrule [ snd ]
                { \Gamma ; \Delta \vdash C : \tau_1 \times \tau_2 }
                { \Gamma ; \Delta \vdash \textsf{snd}\ C : \tau_2 } \\
                \inferrule [ left ]
                { \Gamma ; \Delta \vdash C : \tau_1 }
                { \Gamma ; \Delta \vdash \textsf{left}\ C : \tau_1 + \tau_2 } \and
                \inferrule [ right ]
                { \Gamma ; \Delta \vdash C : \tau_2 }
                { \Gamma ; \Delta \vdash \textsf{right}\ C : \tau_1 + \tau_2 } \and
                \inferrule [ match ]
                { \Gamma ; \Delta \vdash C : \tau_1+\tau_2 \quad \Gamma ; \Delta , X : \tau_1 \vdash C_1 : \tau_3 \quad \Gamma ; \Delta , Y : \tau_2 \vdash C_2 : \tau_3  }
                { \Gamma ; \Delta \vdash (\textsf{match}\ C \ \textsf{with left}\ X \Rightarrow C_1 ; \textsf{right}\ Y \Rightarrow C_2) : \tau_3 }

            \end{mathpar}
            \newpage % end of section

    \end{appendices}


    \printbibliography[heading=bibintoc]

\end{document}