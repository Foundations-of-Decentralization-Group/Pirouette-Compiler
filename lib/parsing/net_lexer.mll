(** Lexer for Pirouette Network IR (Intermediate Representation).
    
    This lexer tokenizes Pirouette Network IR - the intermediate representation
    produced after endpoint projection. Unlike the main lexer which handles
    choreographic syntax, this lexer includes tokens for explicit communication
    primitives like [send], [recv], [choose], and [allow].
    
    {2 Overview}
    
    This lexer is used to parse:
    - Network IR code after endpoint projection (for testing/debugging)
    - Manually written network-level programs
    - Intermediate representations during compilation
    
    {b Note:} Most users write choreographies (parsed by the main lexer), not
    Network IR directly. This lexer is primarily for internal compiler testing
    and advanced use cases.
    
    {2 Differences from Choreographic Lexer}
    
    Additional tokens specific to Network IR:
    - [SEND], [RECV]: Explicit send/receive operations
    - [CHOOSE], [FOR], [ALLOW], [CHOICE]: Choice coordination primitives
    - [RET]: Wrapping local expressions
    - [FROM]: Source specification in receive operations
    
    Missing from Network IR:
    - No choreographic constructs (global send, sync, location-qualified expressions)
    - Communication is always explicit (no implicit coordination)
    
    {2 Network IR Syntax Examples}
    
    {b Sending data:}
    {[
      send Alice x -> Bob
      (* Or using Send primitive: *)
      x := Send(Ret(42), Bob);
    ]}
    
    {b Receiving data:}
    {[
      x := Recv(Alice);
      (* Receive value from Alice *)
    ]}
    
    {b Choice coordination:}
    {[
      (* Chooser side: *)
      ChooseFor(Ready, Bob, continue_expr)
      
      (* Follower side: *)
      AllowChoice(Alice, [
        | Ready -> handle_ready
        | NotReady -> handle_not_ready
      ])
    ]}
    
    {b Local computation wrapped in Ret:}
    {[
      y := Ret(x + 1);
    ]}
    
    {2 Compilation Pipeline Position}
    
    {v
      Choreography  →  Endpoint Projection  →  Network IR  →  OCaml Code
      (Main lexer)                             (This lexer)
    v}
    
    This lexer parses the Network IR level, which contains:
    - Explicit [Send]/[Recv] instead of choreographic sends
    - [ChooseFor]/[AllowChoice] instead of choreographic selects
    - No location-qualified expressions ([Alice] expr)
    - Local computations wrapped in [Ret]
    
    {2 Token Overview}
    
    The lexer handles:
    - Keywords: [send], [recv], [choose], [allow], [choice], [ret], etc.
    - Operators: [+], [-], [*], [/], [&&], [||], comparison operators
    - Literals: integers, strings, booleans
    - Identifiers: variable names, location names
    - Comments: single-line ([--]) and multi-line ([{- ... -}])
    
    {2 Error Handling}
    
    The lexer raises [SyntaxError] for:
    - Unexpected characters
    - Unterminated strings
    - Unterminated multi-line comments
    - Illegal escape sequences in strings
    
    All errors include the problematic lexeme for debugging.
    
    {2 Notes}
    
    - This lexer is generated by ocamllex from this specification file
    - Position tracking is maintained via [next_line] for accurate error reporting
    - Works with [Net_parser] to produce [Parsed_ast.Net.stmt_block]*)

{
  open Lexing
  open Net_parser

  exception SyntaxError of string

  (** [next_line lexbuf] advances the lexer to the next line in the input buffer. *)
  let next_line lexbuf =
    let pos = lexbuf.lex_curr_p in
    lexbuf.lex_curr_p <- { pos with pos_lnum = pos.pos_lnum + 1; pos_bol = lexbuf.lex_curr_pos }
}

let digit = ['0'-'9']
let alpha = ['a'-'z' 'A'-'Z']
let white = [' ' '\t']+
let newline = '\r' | '\n' | "\r\n"

let integer = digit+
let identifier = (alpha | '_' ) (alpha | digit | '_')*

(** [read] is the main lexer function that tokenizes the input. *)
rule read = parse
  | white              { read lexbuf }
  | "--"               { read_single_line_comment lexbuf }
  | "{-"               { read_multi_line_comment lexbuf }
  | '('                { LPAREN }
  | ')'                { RPAREN }
  | ','                { COMMA }
  | '.'                { DOT }
  | ':'                { COLON }
  | ';'                { SEMICOLON }
  | '+'                { PLUS }
  | '-'                { MINUS }
  | '*'                { TIMES }
  | '/'                { DIV }
  | "&&"               { AND }
  | "||"               { OR }
  | "="                { EQ }
  | "!="               { NEQ }
  | "<"                { LT }
  | "<="               { LEQ }
  | ">"                { GT }
  | ">="               { GEQ }
  | '|'                { BAR }
  | '_'                { UNDERSCORE }
  | ":="               { COLONEQ }
  | "->"               { ARROW }
  | "~>"               { TILDE_ARROW }
  | "unit"             { UNIT_T }
  | "int"              { INT_T }
  | "string"           { STRING_T }
  | "bool"             { BOOL_T }
  | "not"              { NOT }
  | "fun"              { FUN }
  | "type"             { TYPE }
  | "true"             { TRUE }
  | "false"            { FALSE }
  | "foreign"          { FOREIGN }
  | "if"               { IF }
  | "then"             { THEN }
  | "else"             { ELSE }
  | "match"            { MATCH }
  | "with"             { WITH }
  | "let"              { LET }
  | "in"               { IN }
  | "fst"              { FST }
  | "snd"              { SND }
  | "left"             { LEFT }
  | "right"            { RIGHT }
  | "send"             { SEND }
  | "recv"             { RECV }
  | "from"             { FROM }
  | "choose"           { CHOOSE }
  | "for"              { FOR }
  | "allow"            { ALLOW }
  | "choice"           { CHOICE }
  | "ret"              { RET }
  | integer as s       { INT (int_of_string s) }
  | identifier as s    { ID (s) }
  | '"'                { read_string (Buffer.create 17) lexbuf }
  | newline            { next_line lexbuf; read lexbuf }
  | _                  { raise (SyntaxError ("Unexpected char: " ^ Lexing.lexeme lexbuf)) }
  | eof                { EOF }

(** [read_string buf] processes string literals recursively in the lexer. *)
and read_string buf = parse
  | '"'       { STRING (Buffer.contents buf) }
  | '\\' ('/' | '\\' | 'b' | 'f' | 'n' | 'r' | 't' as esc)
    { let c = match esc with
        | '/'  -> '/'
        | '\\' -> '\\'
        | 'b'  -> '\b'
        | 'f'  -> '\012'
        | 'n'  -> '\n'
        | 'r'  -> '\r'
        | 't'  -> '\t'
        | _    -> assert false
      in Buffer.add_char buf c;
      read_string buf lexbuf
    }
  | [^ '"' '\\']+
    { Buffer.add_string buf (Lexing.lexeme lexbuf);
      read_string buf lexbuf
    }
  | _   { raise (SyntaxError ("Illegal string character: " ^ Lexing.lexeme lexbuf)) }
  | eof { raise (SyntaxError "String is not terminated") }

(** [read_single_line_comment] processes single-line comments in the lexer. *)
and read_single_line_comment = parse
  | newline { next_line lexbuf; read lexbuf }
  | _       { read_single_line_comment lexbuf }
  | eof     { EOF }

(** [read_multi_line_comment] processes multi-line comments in the lexer. *)
and read_multi_line_comment = parse
  | "-}"    { read lexbuf }
  | newline { next_line lexbuf; read_multi_line_comment lexbuf }
  | _       { read_multi_line_comment lexbuf }
  | eof     { raise (SyntaxError "Comment is not terminated") }